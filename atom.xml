<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dzhu1&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-06-01T17:20:28.985Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dzhu1</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker-虚拟机，代码迁移 和 SOA</title>
    <link href="http://yoursite.com/2016/06/01/Docker/"/>
    <id>http://yoursite.com/2016/06/01/Docker/</id>
    <published>2016-06-01T08:00:00.000Z</published>
    <updated>2016-06-01T17:20:28.985Z</updated>
    
    <content type="html">&lt;p&gt;像Docker这么一款新的软件能够很容易地适用在一些&lt;a href=&quot;https://labs.ctl.io/top-10-startups-built-on-docker/?hvid=1pSn1n&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;初创公司&lt;/a&gt;和一些&lt;a href=&quot;https://github.com/airbnb/synapse&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大型成熟企业&lt;/a&gt;是一个很少见的现象。 dotCloud 作为Docker的创建者和维护者最近获得&lt;a href=&quot;http://venturebeat.com/2014/09/16/docker-funding/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4千万&lt;/a&gt;美元融资。 微软也于2015年11月18日发布了 &lt;a href=&quot;http://venturebeat.com/2014/09/16/docker-funding/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker CLI for Windows&lt;/a&gt;. Docker 将继续在&lt;a href=&quot;https://gigaom.com/2014/10/15/microsoft-and-docker-team-up-to-make-sure-containers-can-play-nice-on-azure/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Azure&lt;/a&gt; 和 Windows Server的下个版本中充当重要作用.&lt;/p&gt;
&lt;p&gt;那么为什么会有这么大的宣传效果呢？&lt;/p&gt;
&lt;p&gt;Docker 解决了软件部署上面最困难的两个问题：毫不费力地构建虚拟机 和 应用代码和部署环境绑定&lt;/p&gt;
&lt;p&gt;构建一个新的定制实例只需要简单地按一下按钮. 对于不同平台之间的代码迁移也是小菜一碟，因为我们的应用代码是和部署环境一起打包的&lt;/p&gt;
&lt;h2 id=&quot;虚拟机&quot;&gt;&lt;a href=&quot;#虚拟机&quot; class=&quot;headerlink&quot; title=&quot;虚拟机&quot;&gt;&lt;/a&gt;虚拟机&lt;/h2&gt;&lt;p&gt;虚拟机是一个很棒的工具，它能够让运行环境从物理硬件上抽象出来。但不幸的是，虚拟机在启动和运行方面有很大的性能影响&lt;/p&gt;
&lt;p&gt;虚拟机上很多问题的原因可以归结为重复的工作。 要理解这个重复的工作，我们可以想一想Linux操作系统的结构。 在Linux Kernel 和 user space之间有明确的划分。Linux Kernel主要负责管理一些比较深层次的任务比如：网络和线程。 user space主要是指kernel以外的部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://keyholesoftware.com/wp-content/uploads/linux-os.png&quot; alt=&quot;linux-os&quot;&gt;&lt;/p&gt;
&lt;p&gt;传统的虚拟机比如&lt;a href=&quot;https://www.virtualbox.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VirtualBox&lt;/a&gt;和&lt;a href=&quot;http://www.vmware.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VMWare&lt;/a&gt;可以在他们的user space运行他们的虚拟机。当在一台机器上面启动一个虚拟机实例，它会开启一个Linux kernel 以及 一个嵌套在user space内部的user space。&lt;br&gt;&lt;img src=&quot;https://keyholesoftware.com/wp-content/uploads/linux-os-with-vm.png&quot; alt=&quot;linux-os-with-vm&quot;&gt;&lt;/p&gt;
&lt;p&gt;这就是为什么之前提交的重复的来由。为什么在user space里面还要有一个Linux kernal既然已经有一个Linux kernel可以被使用了？但它没有这样做。 这就是Docker的创造者最初意识到的。 只要虚拟机的Linux kernel和宿主机器匹配，就已经有了一个明确的划分，虚拟机的user space就应该直接利用它&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://keyholesoftware.com/wp-content/uploads/linux-os-with-docker-vm.png&quot; alt=&quot;linux-os-with-docker-vm&quot;&gt;&lt;/p&gt;
&lt;p&gt;当一个Docker的虚拟机启动时，它会把虚拟机的user space附着在宿主机器的Linux kernel上。这就意味着启动仅仅是毫秒级别的事情。性能也达到直接在宿主机器上运行该软件的&lt;a href=&quot;http://bodenr.blogspot.com/2014/05/kvm-and-docker-lxc-benchmarking-with.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;97%&lt;/a&gt;. Docker就是具有如此大的优点而没有任何的缺点。另外。。。。。。&lt;/p&gt;
&lt;h2 id=&quot;解决了部署问题&quot;&gt;&lt;a href=&quot;#解决了部署问题&quot; class=&quot;headerlink&quot; title=&quot;解决了部署问题&quot;&gt;&lt;/a&gt;解决了部署问题&lt;/h2&gt;&lt;p&gt;一个Docker的虚拟机是从一个定义良好的脚本&lt;a href=&quot;http://docs.docker.com/reference/builder/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dockerfile&lt;/a&gt;产生出来的。这个Dockerfile指定了适用的Linux的类型和版本，需要安装的软件，需要打开的端口，怎么样获取源代码等等。所有你需要的东西都被包含在这一个文件里面了。下面是一个Dockerfile的例子仅供参考：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM ubuntu:12.04&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MAINTAINER Zach Gardner &amp;lt;zgardner@keyholesoftware.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Update apt-get&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Create container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN mkdir /container&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN mkdir /container/project&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install NodeJS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get --yes install python g++ make checkinstall fakeroot wget&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN src=$(mktemp &lt;span class=&quot;_&quot;&gt;-d&lt;/span&gt;) &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$src&lt;/span&gt; &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wget -N http://nodejs.org/dist/node-latest.tar.gz &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tar xzvf node-latest.tar.gz &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; node-v* &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ./configure &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fakeroot checkinstall -y --install=no --pkgversion $(&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; $(&lt;span class=&quot;built_in&quot;&gt;pwd&lt;/span&gt;) | sed -n -re&lt;span class=&quot;string&quot;&gt;&quot;s/.+node-v(.+)$/\1/p&quot;&lt;/span&gt;) make -j$(($(nproc)+1)) install &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dpkg -i node_* &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf &lt;span class=&quot;variable&quot;&gt;$src&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install NPM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get --yes install curl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN curl --no-check-certificate https://www.npmjs.org/install.sh | sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install Bower&#39;s dependencies&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get install --yes git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install PhantomJS dependencies&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get install --yes freetype* fontconfig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Move source code to container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ADD / /container/project&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install NPM dependencies&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /container/project/ &amp;amp;&amp;amp; npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install Project&#39;s Bower dependencies&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /container/project &amp;amp;&amp;amp; (&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;_&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;n&quot;&lt;/span&gt; | ./node_modules/bower/bin/bower install --allow-root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Compile code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /container/project &amp;amp;&amp;amp; ./node_modules/grunt-cli/bin/grunt build&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Start server&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMD /container/project/node_modules/grunt-cli/bin/grunt --gruntfile /container/project/Gruntfile.js prod&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个脚本中首先定义了是用的 Ubuntu 12.04。安装了NodeJS,NPM和git。从代码仓库里面复制了源码，下载了运行时的依赖，编译了代码，启动了server。&lt;/p&gt;
&lt;p&gt;当你把Dockerfile放到Docker上时，它会产生一个Docker的镜像。最后的方式来理解Docker镜像就是把它当成一个自我包含的zip文件，它包含了要运行一个应用所需的所有元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://keyholesoftware.com/wp-content/uploads/docker-image.png&quot; alt=&quot;docker-image&quot;&gt;&lt;/p&gt;
&lt;p&gt;源代码和运行环境被整合到了一起，与传统的部署方式相比较这是一个全新的思维模式。与其通过移动代码，人工执行一段shell脚本来更新环境，你完全可以通过一种最好的方式来做，那就是传递一个全新的Docker镜像到不同的平台。实质上不需要任何的人为干预，这就减少了人为犯错误的机会。最妙的就是当QA测试通过一个特别的版本时，你能够很确信你的应用程序不会因为迁移到不同的平台而发生任何改变。&lt;/p&gt;
&lt;p&gt;有意思的是，Docker这种传输Docker镜像的方式和&lt;a href=&quot;https://keyholesoftware.com/2014/08/18/functional-reactive-programing-and-javascript/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;响应式编程&lt;/a&gt;的一些研究有着内在的关联。状态管理是一个应用当中最困难的事情。易变性对于创建安全性的代码来说可不是一件小事。把这样的思想传递对不变数据的处理上来，CPU就可以在这种更容易的方式下来优化线程和操作。Docker遵循的思路是去除在不同的平台上进行软件更新的概念。这样我们只要简单地用一个新的镜像来替代现有的镜像，而不需要针对现有的镜像进行升级。也不需要额外的脚本来处理诸如java版本变更等类似的事情。Docker把这些关于你软件运行的平台的不确定因素完全排除，它只根据开发者在Dockerfile里面定义的内容来执行。&lt;/p&gt;
&lt;p&gt;在不同的平台之间迁移镜像是一件很小的事情。Docker的镜像可以被push到一个Docker registry （public or private）,然后可以被pull到期望的平台上面。语法和git的语法很相似：&lt;/p&gt;
&lt;p&gt;在开发平台上&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker push zgardner/myapp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在产品平台上&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull zgardner/myapp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker run -i -t zgardner/myapp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在上面的例子里，我们首先把myapp push到Docker registry。然后我们又把它pull到更高层次的平台上面并运行它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://keyholesoftware.com/wp-content/uploads/docker-dev-to-prod1.png&quot; alt=&quot;docker-dev-to-prod1&quot;&gt;&lt;/p&gt;
&lt;p&gt;运行Docker镜像的载体我们称之为Docker容器。这里我省略了一些步骤，比如如何停止一个现存的容器，怎么样来定义一个Docker容器的通信端口等等。那些事情这些使用Docker的机构可以自行定义。&lt;/p&gt;
&lt;h2 id=&quot;SOA-Service-Oriented-Architecture-像切面包一样简单&quot;&gt;&lt;a href=&quot;#SOA-Service-Oriented-Architecture-像切面包一样简单&quot; class=&quot;headerlink&quot; title=&quot;SOA(Service Oriented Architecture):像切面包一样简单&quot;&gt;&lt;/a&gt;SOA(Service Oriented Architecture):像切面包一样简单&lt;/h2&gt;&lt;p&gt;Docker是第一个真正的开发运营工具。它让开发者能如此简单地定义他们的代码所需的运行环境。它也消除了由于需要升级环境而带来的压力和焦虑。&lt;/p&gt;
&lt;p&gt;Docker的镜像是一个静态的容器那就意味着对于持久化的数据需要在应用之外来存储。通常的做法是在定义一个Docker容器的时候通过mount一个AWS的硬盘来实现。这也意味着这个应用所包含的code需要短信精悍，因为它将运行在一个隔离的环境下，它需要被定义成可以独立运行在一个孤岛之上。&lt;/p&gt;
&lt;p&gt;这就很倾向于一种SOA(Service Oriented Architecture)架构。SOA和我们通常意义上的应用API的组成是不同的。通常情况下我们认为的应用是一个系统由很多细小的技术部分组成。比如产品，客户，资金和定时任务等，有些技术部分是由其他一些软件公司提供的应用产品。传统的方式要么是共享代码，但这通常不起作用，因为原始作者的意图不可能轻易领会，又或者拷贝所有的代码把它们和在一起，但很明显这也不会有什么用。&lt;/p&gt;
&lt;p&gt;基于SOA的一个应用是完全针对不同的目的而设计的。在SOA中，一个应用是通过组合无数个应用来实现自身的业务逻辑的，比如上面提到的一些技术部分都是商业场景中需要的组成部分。 在不同的应用中这些元素都是同样的，但是有可能根据不同的UI它们的使用方式不同而已。如果这些公用的业务能够被很好地定义成一致性的接口，那么从设计上来讲它们就是可以被重用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://keyholesoftware.com/wp-content/uploads/docker-soa.png&quot; alt=&quot;docker-soa&quot;&gt;&lt;/p&gt;
&lt;p&gt;机构使用SOA的主要关注点在于它能够很快且高效地组成很多新的应用。&lt;a href=&quot;http://apievangelist.com/2012/01/12/the-secret-to-amazons-success-internal-apis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon&lt;/a&gt;是第一个采用这种观点的先驱。其它大公司小公司也陆续采用了这种方式因为它确实有用。&lt;/p&gt;
&lt;p&gt;Docker本身看上去就是一个SOA. 每个单独的服务都可以被设想成一个单独的Dockfile。在不同的平台上迁移服务也很简单，只要push一个静态的Docker镜像到Docker registry，然后再pull down就行了。它们被很好地隔离了因为他们原本就可以在一个独立虚拟机上运行的天性。利用API文档工具比如&lt;a href=&quot;https://helloreverb.com/developers/swagger&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swagger&lt;/a&gt;能够更好地定义一个服务。&lt;/p&gt;
&lt;p&gt;Docker也被一些公司例如&lt;a href=&quot;http://nirmata.com/2014/08/getting-started-microservices-using-netflix-oss-docker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Netfix用来实现微服务&lt;/a&gt;。这些服务很传统的SOA服务的界限不同。传统的服务有很多的依赖，通常很难独立出来或者被包含。微服务主要关注在一些特别小，可重用并尽量与环境无关的服务上面。Docker的隔离性能够确保这些微服务可以被部署在任何地方&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;Docker是一个很强大的工具，我们相信它在未来的几年里将成为行业的标准。用户使用了它将会节省时间和精力。Docker能让开发者和企业工程师不再为构建和部署问题而困扰，转而关注在如果创造更完美的应用上。Docker前途无可限量！！！&lt;/p&gt;
&lt;p&gt;翻译自&lt;a href=&quot;http://www.codeproject.com/Articles/861625/Docker-VMs-Code-Migration-and-SOA-Solved&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;像Docker这么一款新的软件能够很容易地适用在一些&lt;a href=&quot;https://labs.ctl.io/top-10-startups-built-on-docker/?hvid=1pSn1n&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;初创公司&lt;
    
    </summary>
    
      <category term="Development" scheme="http://yoursite.com/categories/Development/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
</feed>
